<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PhaseEstimation.qcnn &mdash; PhaseEstimationThroughQML 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PhaseEstimationThroughQML
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PhaseEstimationThroughQML</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>PhaseEstimation.qcnn</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PhaseEstimation.qcnn</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module implements the base functions to implement a Quantum Convolutional Neural Network (QCNN) for the (ANNNI) Ising Model. &quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>
<span class="kn">from</span> <span class="nn">pennylane</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
<span class="kn">from</span> <span class="nn">jax.example_libraries</span> <span class="kn">import</span> <span class="n">optimizers</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">tqdm</span><span class="o">,</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">PhaseEstimation</span> <span class="kn">import</span> <span class="n">circuits</span><span class="p">,</span> <span class="n">vqe</span><span class="p">,</span> <span class="n">general</span> <span class="k">as</span> <span class="n">qmlgen</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="c1">##############</span>

<div class="viewcode-block" id="qcnn_circuit"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.qcnn_circuit">[docs]</a><span class="k">def</span> <span class="nf">qcnn_circuit</span><span class="p">(</span><span class="n">params</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">N</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_outputs</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Building function for the QCNN circuit:</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : np.ndarray</span>
<span class="sd">        Array of QCNN parameters</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of qubits</span>
<span class="sd">    n_outputs : int</span>
<span class="sd">        Output vector dimension</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Total number of parameters needed to build this circuit</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Array of indexes of not-measured wires (due to pooling)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Wires that are not measured (through pooling)</span>
    <span class="n">active_wires</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Visual Separation VQE||QCNN</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
    <span class="n">qml</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

    <span class="c1"># Index of the parameter vector</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Iterate Convolution+Pooling until we only have a single wires</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">wall_gate</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">circuits</span><span class="o">.</span><span class="n">wall_cgate_serial</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_wires</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_outputs</span><span class="p">:</span> <span class="c1"># Repeat until the number of active wires</span>
                                         <span class="c1"># (non measured) is equal to n_outputs</span>
        <span class="c1"># Convolute</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">convolution</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="c1"># Measure wires and apply rotations based on the measurement</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">active_wires</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">RX</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        
        <span class="n">qml</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>
        
    <span class="n">circuits</span><span class="o">.</span><span class="n">wall_cgate_serial</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">CNOT</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">wall_gate</span><span class="p">(</span><span class="n">active_wires</span><span class="p">,</span> <span class="n">qml</span><span class="o">.</span><span class="n">RY</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="c1"># Return the number of parameters</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">active_wires</span></div>

<div class="viewcode-block" id="qcnn"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.qcnn">[docs]</a><span class="k">class</span> <span class="nc">qcnn</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vqe</span> <span class="p">:</span> <span class="n">vqe</span><span class="o">.</span><span class="n">vqe</span><span class="p">,</span> <span class="n">qcnn_circuit</span> <span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">n_outputs</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class for the QCNN algorithm</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vqe : class</span>
<span class="sd">            VQE class</span>
<span class="sd">        qcnn_circuit :</span>
<span class="sd">            Function of the QCNN circuit</span>
<span class="sd">        n_outputs : int</span>
<span class="sd">            Output vector dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vqe</span> <span class="o">=</span> <span class="n">vqe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_states</span> <span class="o">=</span> <span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">n_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">n_outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qcnn_circuit_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">qcnn_circuit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n_outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_active_wires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qcnn_circuit_fun</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_params</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">vqe</span><span class="o">.</span><span class="n">device</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vqe</span><span class="o">.</span><span class="n">vqe_params0</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_train</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_test</span>  <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">circuit_drawer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qcnn_circuit_fun</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_params</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_active_wires</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">circuit_drawer</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_vqe_qcnn_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vqe_p</span><span class="p">,</span> <span class="n">qcnn_p</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Circuit:</span>
<span class="sd">        VQE + QCNN</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vqe</span><span class="o">.</span><span class="n">circuit</span><span class="p">(</span><span class="n">vqe_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qcnn_circuit_fun</span><span class="p">(</span><span class="n">qcnn_p</span><span class="p">)</span>
    
    <span class="c1"># Training function</span>
<div class="viewcode-block" id="qcnn.train"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.qcnn.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lr</span> <span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_epochs</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">train_index</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">loss_fn</span> <span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">circuit</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Training function for the QCNN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lr : float</span>
<span class="sd">            Learning rate for the ADAM optimizer</span>
<span class="sd">        n_epochs : int</span>
<span class="sd">            Total number of epochs for each learning</span>
<span class="sd">        train_index : np.ndarray</span>
<span class="sd">            Index of training points</span>
<span class="sd">        loss_fn : function</span>
<span class="sd">            Loss function</span>
<span class="sd">        circuit : bool</span>
<span class="sd">            if True -&gt; Prints the circuit</span>
<span class="sd">        plot : bool</span>
<span class="sd">            if True -&gt; It displays loss curve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># -1 could be in the labels as [-1, -1] when training</span>
        <span class="c1"># ANNNI model which non-trivial cases have no solution</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">[</span><span class="n">train_index</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">test_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">)),</span> <span class="n">train_index</span><span class="p">)</span>
            <span class="n">X_test</span><span class="p">,</span> <span class="n">Y_test</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">[</span><span class="n">test_index</span><span class="p">]),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we are traing an ANNNI model, we have to first restrict on the trivial cases:</span>
            <span class="c1"># L = 0, K = whatever</span>
            <span class="c1"># K = 0, L = whatever</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">model_params</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">model_params</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">)</span>
            
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">mask</span><span class="p">,:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># The labels stored in the Hamiltonian class are:</span>
            <span class="c1">#   &gt; [ 1, 1] for paramagnetic states</span>
            <span class="c1">#   &gt; [ 0, 1] for ferromagnetic states</span>
            <span class="c1">#   &gt; [ 1, 0] for antiphase states</span>
            <span class="c1">#   &gt; [ 0, 0] not used</span>
            <span class="c1">#   &gt; [-1,-1] for states with no analytical solutions</span>
            <span class="c1"># qml.probs(wires = active_wires) will output the following probabilities:</span>
            <span class="c1"># (example for a two qbits output) </span>
            <span class="c1"># p(00), p(01), p(10), p(11)</span>
            <span class="c1"># The labels need to be transformed accordingly</span>
            <span class="c1">#     [0,0] -&gt; [1,0,0,0] trash case</span>
            <span class="c1">#     [0,1] -&gt; [0,1,0,0] for ferromagnetic</span>
            <span class="c1">#     [1,0] -&gt; [0,0,1,0] for antiphase</span>
            <span class="c1">#     [1,1] -&gt; [0,0,0,1] for paramagnetic</span>
            <span class="n">Ymix</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">Ymix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># Trash</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">Ymix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># Ferromagnetic</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">Ymix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>   <span class="c1"># Antiphase</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">label</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">Ymix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># Paramagnetic</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ymix</span><span class="p">)</span>
            
            <span class="c1"># The indexes of test are</span>
            <span class="c1"># All indexes (only analitical) \ train_index</span>
            <span class="n">test_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)),</span> <span class="n">train_index</span><span class="p">)</span>
            
            <span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">train_index</span><span class="p">]</span>
            <span class="n">X_test</span><span class="p">,</span> <span class="n">Y_test</span>   <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">test_index</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">test_index</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">circuit</span><span class="p">:</span>
            <span class="c1"># Display the circuit</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;+--- CIRCUIT ---+&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># QCircuit: Circuit(VQE, QCNNparams) -&gt; probs</span>
        <span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">qcnn_circuit_prob</span><span class="p">(</span><span class="n">vqe_p</span><span class="p">,</span> <span class="n">qcnn_p</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vqe_qcnn_circuit</span><span class="p">(</span><span class="n">vqe_p</span><span class="p">,</span> <span class="n">qcnn_p</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_active_wires</span><span class="p">])</span>
        
        <span class="n">params</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Gradient of the Loss function</span>
        <span class="n">jd_loss_fn</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span>
            <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">qcnn_circuit_prob</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Update function</span>
        <span class="c1"># Returns updated parameters, updated state of the optimizer</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">):</span>
            <span class="n">grads</span> <span class="o">=</span> <span class="n">jd_loss_fn</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">opt_state</span> <span class="o">=</span> <span class="n">opt_update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">grads</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">get_params</span><span class="p">(</span><span class="n">opt_state</span><span class="p">),</span> <span class="n">opt_state</span>
        
        <span class="c1"># Definying following function:</span>
        <span class="c1"># jitted loss function for training set loss(params)</span>
        <span class="n">train_loss_fn</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">qcnn_circuit_prob</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># jitted loss function for test set loss(params)</span>
        <span class="n">test_loss_fn</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">Y_test</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">qcnn_circuit_prob</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Initialize tqdm progress bar</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Defining an optimizer in Jax</span>
        <span class="n">opt_init</span><span class="p">,</span> <span class="n">opt_update</span><span class="p">,</span> <span class="n">get_params</span> <span class="o">=</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
        <span class="n">opt_state</span> <span class="o">=</span> <span class="n">opt_init</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        
        <span class="n">loss_history</span><span class="p">,</span> <span class="n">loss_history_test</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1"># Training loop:</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">opt_state</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">opt_state</span><span class="p">)</span>

            <span class="c1"># Every 100 iterations append the updated training (and testing) loss</span>
            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loss_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">train_loss_fn</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y_test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">loss_history_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_loss_fn</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
                    
            <span class="c1"># Update progress bar</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="s2">&quot;Cost: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loss_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Update qcnn class after training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_train</span> <span class="o">=</span> <span class="n">loss_history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_test</span> <span class="o">=</span> <span class="n">loss_history_test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loss_history</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loss_history</span><span class="p">),</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Training Loss&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">loss_history_test</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">loss_history_test</span><span class="p">),</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Test Loss&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Loss history&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average Cross entropy&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Epoch&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>

<div class="viewcode-block" id="qcnn.save"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.qcnn.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves QCNN parameters to file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            File where to save the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">things_to_save</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qcnn_circuit_fun</span><span class="p">]</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">things_to_save</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid name for file&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">filename_vqe</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_qcnn</span> <span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">qcnn</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load QCNN from VQE file and QCNN file</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename_vqe : str</span>
<span class="sd">        Name of the file from where to load the VQE class</span>
<span class="sd">    filename_qcnn : str</span>
<span class="sd">        Name of the file from where to load the main parameters of the QCNN class</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    class</span>
<span class="sd">        QCNN class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_vqe</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_qcnn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">loaded_vqe</span> <span class="o">=</span> <span class="n">vqe</span><span class="o">.</span><span class="n">load_vqe</span><span class="p">(</span><span class="n">filename_vqe</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_qcnn</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">qcnn_circuit_fun</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">loaded_qcnn</span> <span class="o">=</span> <span class="n">qcnn</span><span class="p">(</span><span class="n">loaded_vqe</span><span class="p">,</span> <span class="n">qcnn_circuit_fun</span><span class="p">)</span>
        <span class="n">loaded_qcnn</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="k">return</span> <span class="n">loaded_qcnn</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid name for file&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_trainset_gaussian"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.get_trainset_gaussian">[docs]</a><span class="k">def</span> <span class="nf">get_trainset_gaussian</span><span class="p">(</span><span class="n">vqeclass</span> <span class="p">:</span> <span class="n">vqe</span><span class="o">.</span><span class="n">vqe</span><span class="p">,</span> <span class="n">nS</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sigma</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draw randomly samples from the training for each axis according to the gaussian distribution</span>
<span class="sd">    centered around the phase transition on the axis and std sigma</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vqeclass : vqe.vqe</span>
<span class="sd">        VQE class to get the side size of the system</span>
<span class="sd">    nS : int</span>
<span class="sd">        Number of samples to draw in total</span>
<span class="sd">    sigma : float</span>
<span class="sd">        Standard deviation of the two distributions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        List of the indexes of the subset of the training set</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">side</span> <span class="o">=</span> <span class="n">vqeclass</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">side</span>
    <span class="k">if</span> <span class="n">nS</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">side</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Subset size too large!&#39;</span><span class="p">)</span>
    <span class="n">nS</span> <span class="o">=</span> <span class="n">nS</span> <span class="o">//</span> <span class="mi">2</span>    <span class="c1"># Size of the subset -&gt; Number of samples to draw among each axis</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">side</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># Mean of the distributions</span>
    
    <span class="n">training_set</span> <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Get Y training set:</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nS</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span> <span class="c1"># Draw randomly according to the gaussian distribution</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training_set</span><span class="p">:</span> <span class="c1"># No duplicates allowed</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sample</span> <span class="o">&lt;</span> <span class="n">side</span><span class="p">:</span> <span class="c1"># Check if the drawn sample is in range</span>
                <span class="n">training_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
    <span class="c1"># Get X training set: </span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">nS</span><span class="p">:</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span> <span class="o">+</span> <span class="n">side</span> <span class="c1"># Draw randomly according to the gaussian distribution (and shift to the X axis)</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training_set</span><span class="p">:</span> <span class="c1"># No duplicates allowed</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="n">side</span> <span class="ow">and</span> <span class="n">sample</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">side</span><span class="p">:</span> <span class="c1"># Check if the drawn sample is in range</span>
                <span class="n">training_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">training_set</span><span class="p">)</span></div>

<div class="viewcode-block" id="ANNNI_accuracy"><a class="viewcode-back" href="../../PhaseEstimation.html#PhaseEstimation.qcnn.ANNNI_accuracy">[docs]</a><span class="k">def</span> <span class="nf">ANNNI_accuracy</span><span class="p">(</span><span class="n">qcnnclass</span> <span class="p">:</span> <span class="n">qcnn</span><span class="p">,</span> <span class="n">plot</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute accuracy of the QCNN of the whole ANNNI state space</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qcnnclass : qcnn</span>
<span class="sd">        QCNN class</span>
<span class="sd">    plot : bool</span>
<span class="sd">        if True -&gt; displays the plot of the accuracy:</span>
<span class="sd">                if green: sample correctly classified</span>
<span class="sd">                if red  : sample wrongly classified</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Accuracy : (# samples correctly classified)/(# samples) (0,1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">qcnnclass</span><span class="o">.</span><span class="n">_vqe_qcnn_circuit</span>
    <span class="n">side</span>    <span class="o">=</span> <span class="n">qcnnclass</span><span class="o">.</span><span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">side</span>
    
    <span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">qcnnclass</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">qcnn_circuit_prob</span><span class="p">(</span><span class="n">params_vqe</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">circuit</span><span class="p">(</span><span class="n">params_vqe</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="p">[</span><span class="n">qml</span><span class="o">.</span><span class="n">probs</span><span class="p">(</span><span class="n">wires</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qcnnclass</span><span class="o">.</span><span class="n">final_active_wires</span><span class="p">]</span>
    
    <span class="n">vcircuit</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">qcnn_circuit_prob</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">qcnnclass</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Get the predictions of the QCNN among all states of the VQE</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vcircuit</span><span class="p">(</span><span class="n">qcnnclass</span><span class="o">.</span><span class="n">vqe_params</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Compare predictions to actual states</span>
    <span class="c1"># applying inequalities to theoretical curves</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qcnnclass</span><span class="o">.</span><span class="n">vqe</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">n_states</span><span class="p">):</span>
        <span class="c1"># compute coordinates and normalize for x in [0,1]</span>
        <span class="c1"># and y in [0,2]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">//</span><span class="n">side</span><span class="p">)</span><span class="o">/</span><span class="n">side</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">idx</span><span class="o">%</span><span class="n">side</span><span class="p">)</span><span class="o">/</span><span class="n">side</span>
        
        <span class="c1"># If x==0 we get into 0/0 on the theoretical curve</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">.5</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qmlgen</span><span class="o">.</span><span class="n">paraferro</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qmlgen</span><span class="o">.</span><span class="n">paraanti</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">correct</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correct</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">side</span><span class="o">*</span><span class="n">side</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="p">(</span><span class="n">side</span><span class="p">,</span><span class="n">side</span><span class="p">))),</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;RdYlGn&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">accuracy</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Saverio Monaco.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>